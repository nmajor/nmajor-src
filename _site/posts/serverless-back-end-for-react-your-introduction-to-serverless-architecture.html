<!DOCTYPE html>
<html lang="en">
   <head>
       <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<title>Serverless Back-End for React - Your Introduction to Serverless Architecture &#9642; NMajor Blog</title>
<!--
<meta name="description" content="I believe Serverless is the next big thing in web development. I discuss the what, why, and how of Serverless. Then I show you how to build a simple backend for a react app. You’ll be surprised how easy it is.
">
-->
<meta name="description" content="A blog filled with adventures in tech">
<meta name="keywords" content="serverless, react, aws">
<link rel="canonical" href="http://localhost:4000/posts/serverless-back-end-for-react-your-introduction-to-serverless-architecture">
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Serverless Back-End for React - Your Introduction to Serverless Architecture" />
<meta name="twitter:description" content="A blog filled with adventures in tech" />
<meta name="twitter:image" content="http://localhost:4000" />
<meta name="author" content="">
<link rel="author" href="">
<meta property="og:locale" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="Serverless Back-End for React - Your Introduction to Serverless Architecture">
<meta property="og:description" content="A blog filled with adventures in tech">
<meta property="og:url" content="http://localhost:4000/posts/serverless-back-end-for-react-your-introduction-to-serverless-architecture">
<meta property="og:site_name" content="NMajor Blog">
<link rel="stylesheet" href="/assets/vendor/normalize-css/normalize.css">
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700,700i">
<style>
    html {
      font-family: "Open Sans", "Helvetica Neue", sans-serif;
    }
</style>
<link rel="stylesheet" href="/assets/css/bf.css">
   <body>
       <div class="wrapper" id="blep">
          <header>
   <div class="menu">
     <div class="logo">
        <img src="/uploads/me4.jpg" />
        <a href="/">NMajor Blog</a>
     </div>
       <ul>
           <li><a href="/about">About</a>
           <li><a href="/projects">Projects</a>
           <li><a href="/archive">Archive</a>
       </ul>
   </div>
   <div class="social">
     <ul>
       <li>
            <a href="https://github.com/nmajor" target="_blank" class="smaller">
              <span class="icon-github"></span>
            </a>
       <li>
            <a href="https://twitter.com/_nmajor" target="_blank" class="smaller">
              <span class="icon-twitter"></span>
            </a>
       <li>
            <a href="https://linkedin.com/in/nmajor" target="_blank" class="smaller">
              <span class="icon2-linkedin"></span>
            </a>
       <li>
            <a href="http://blog.nmajor.com" target="_blank" class="smaller">
              <span class="icon2-globe"></span>
            </a>
       <li>
            <a href="https://instagram.com/_nmajor" target="_blank" class="smaller">
              <span class="icon2-instagram"></span>
            </a>
       <li>
            <a href="https://youtube.com/channel/UCV_jmt214-hitQUiczsYhsQ" target="_blank" class="smaller">
              <span class="icon-youtube"></span>
            </a>
       <li>
            <a href="mailto:nick@nmajor.com" target="_blank">
              <span class="icon-mail_outline"></span>
            </a>
       <li>
            <a href="/feed.xml" target="_blank">
                <span class="icon-rss_feed"></span>
            </a>
     </ul>
   </div>
</header>
<article class="post">
 <div class="post-title-container
  no-hero-margin
  ">
    <!--Post hero image source-->
   <div class="heading-container ">
     <h1>
          Serverless Back-End for React - Your Introduction to Serverless Architecture
     </h1>
      <span class="published-at">Published Jan 29, 2018</span>
      &#9642;
      <span class="post-tags">
            <a href="/tag/serverless">#serverless</a>
            <a href="/tag/react">#react</a>
            <a href="/tag/aws">#aws</a>
      </span>
          <a href="/posts/serverless-back-end-for-react-your-introduction-to-serverless-architecture" title="Serverless Back-End for React - Your Introduction to Serverless Architecture"><img class="hero-image" src="/uploads/2018/01/29/serverless-hero.png" /></a>
   </div>
 </div>
   <p>I believe Serverless is the next big thing in web development. I discuss the what, why, and how of Serverless. Then I show you how to build a simple backend for a react app. You’ll be surprised how easy it is.
<p class="lead">
<p>What’s the opposite of the boy who cried wolf? The boy who cried that something amazing was coming? The boy who cried free pizza?
<p>Serverless architecture might be the free pizza equivalent of web technologies in terms of how amazing it is. It’s still very new tech, but the more I learn about it and use it, the more I am convinced that it’s the future of web development.
<p>In this post:
<p>I’m going to go over what serverless architecture is and how using it differs from working with a traditional web framework. I’ll also go over the benefits of serverless.
<p>Then, I’ll show you how you can make and deploy a simple serverless back-end for a React app using <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> (Amazons’s serverless platform).
<p>And finally, to wrap it up, I’ll go over some of the drawbacks of the serverless architecture.
<p><em>Side note: I’m going to be using Amazon’s platform for all of the examples in this post, but be aware that there are other serverless providers out there. The implementation details are going to be different depending on which one you use.</em>
<p>Let’s get started!
<h2 id="what-is-serverless">What is serverless?</h2>
<p>Okay, okay, technically the term serverless is a little misleading. The term serverless refers to FaaS or Function as a Service. We call it serverless because, although these functions still run on a server somewhere, you don’t have to pay for, set up, or maintain a server yourself.
<p>FaaS is a form of <a href="https://www.avantica.net/blog/event-based-computing-aws-lambda">event based computing</a>. Basically, you configure functions to be triggered by specific events. These functions are executed in little (or big) containers containing all of the dependencies they need to run.
<p>Here is the cool part — these functions can be triggered by <a href="http://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html">all sorts of events</a>.
<p>Here are a few of the events AWS Lambda can be triggered by:
<ul>
 <li>Amazon S3 Events — like when an object is added or deleted from S3.
 <li>Amazon Simple Email Service — when you receive an email.
 <li>Amazon Alexa — yes, you can trigger functions by talking to Alexa.
 <li>Amazon DynamoDB — trigger when data changes in your database.
 <li>Scheduled Events — self explanatory.
 <li>Amazon API Gateway — the Holy Grail!
</ul>
<p>Amazon API Gateway! You can trigger these events using an API. Aaaaand, not only can you trigger a function with an API request, that function can send back a response! That’s a back-end!
<p>When you break down any web framework, even big ones like Rails, they all boil down each request to the execution and return value of one function. In the case of Rails, each request is mapped to one controller action, and all of the rest of the code is just helping the controller build the response.
<p>It seems a little strange at first to think about web apps in terms of individual functions, but all of the other parts of the framework are there, they are just being handled by the infastructure.
<p>A good example of this is the routing. In serverless you use a configuration file to tell the infastructure which API events to connect to which functions, so none of your actual code gets involved in the routing.
<h2 id="why-serverless">Why Serverless</h2>
<p><strong>Cost</strong><br />
One of the biggest benefits of serverless is cost. You only pay for the request and runtime of the function. This means no more paying for idle servers. This ends up saving some companies a lot of money.
<p><strong>Scalability</strong><br />
Serverless solves most scaling problems because each function is its own little microservice that can scale automatically by the provider.
<p><em>Some of these other benefits are pretty subjective, but they come up frequently in discussions of serverless online.</em>
<p><strong>Time to Market</strong><br />
One claimed benefit is a faster time to market. This actually makes sense. You save a lot of time not having to worry about dev ops, and some of the things you used to have to write code for are handled by the infastructure, leaving you more time to develop the important parts of your application.
<p><strong>Decreased Software Complexity</strong><br />
Of course it’s still possible to write bad, tightly coupled code in serverless, but splitting your application into distinct functions helps you write better, loosely coupled code, leading to less complex software.
<p><strong>Shorter Release Cycles</strong><br />
If everything is loosely coupled, it can mean shorter release cycles.
<p><strong>Industry Direction</strong><br />
Another <strong>why</strong> is the fact that this seems to be the way the industry is heading. For a while now, the industry has been trending hard towards bigger front-ends. As front-end frameworks like Angular and React have been doing more and more of the heavy lifting for the client, the back-ends for web apps have been shrinking. Serverless seems to be testing just how small a back-end can be.
<h2 id="how">How</h2>
<p>Here is the moment you’ve been waiting for!
<p>In preparation for this post, I built a little React app called Business Cardistry. The app lets people design colorful business cards.
<table>
 <tbody>
   <tr>
     <td><a href="http://cardistry.nmajor.com">Demo</a>
     <td><a href="https://github.com/nmajor/business-cardistry-client">Source</a>
</table>
<p>Now, I want this app to let users actually download PDFs of their business card design. To do that, I am going to need a little back-end processing. Specifically, I want one endpoint that will receive the HTML of the business card design and return a URL the user can use to download a PDF of the design.
<p>Before we begin, let’s take a moment to appreciate the fact that we are going to be sending HTML <em>from the client</em> to the back-end. lol.
<p>Here is our roadmap:
<ul>
 <li>Set up and create a new project
 <li>Deploy and send a test request
 <li>Set up an S3 Bucket
 <li>Code our function
 <li>Testing and final deployment
</ul>
<p>Let’s get started…
<h3 id="set-up-and-create-a-new-project">Set up and Create a New Project</h3>
<p>The Serverless Toolkit over at <a href="https://serverless.com">serverless.com</a> has an amazing framework with incredible documentation, and that is what we are going to be using today.
<p>You should already have <code class="highlighter-rouge">node v6.5.0</code> or higher installed.
<p>First, install the serverless CLI: <code class="highlighter-rouge">npm install -g serverless</code>.
<p>Then, follow <a href="https://serverless.com/framework/docs/providers/aws/guide/credentials/">these instructions</a> to set up your AWS account and credentials.
<p>After following those instructions, you should have an Access Key ID, and a Secret Access Key, and both should be added to your shell environment under the variable names <code class="highlighter-rouge">AWS_ACCESS_KEY_ID</code> and <code class="highlighter-rouge">AWS_SECRET_ACCESS_KEY</code>. This is where the serverless CLI looks for credentials when deploying.
<p>Now that you have everything set up, let’s create our back-end by running this command:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>serverless create --template aws-nodejs --path business-cardistry
</pre></table>
</div>
</div>
<p>This should create a new folder for us called <code class="highlighter-rouge">business-cardistry</code>. Let’s go into that folder and have a look around.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre><td class="code"><pre>$ cd business-cardistry
$ ls -lah
total 24
drwxr-xr-x    5 nmajor  staff   160B Dec 27 13:37 .
drwxr-xr-x  110 nmajor  staff   3.4K Dec 27 13:37 ..
-rw-r--r--    1 nmajor  staff    86B Dec 27 13:37 .gitignore
-rw-r--r--    1 nmajor  staff   466B Dec 27 13:37 handler.js
-rw-r--r--    1 nmajor  staff   2.8K Dec 27 13:37 serverless.yml
</pre></table>
</div>
</div>
<p>As you can see, aside from <code class="highlighter-rouge">.gitignore</code>, we only have two files, <code class="highlighter-rouge">handler.js</code> and <code class="highlighter-rouge">serverless.yml</code>. Later, this file structure can grow into any structure we need to keep our code organized, but everything comes back to these two files.
<p>The best way to learn how these files work is to dive in and change them a bit to see how they work.
<p>I opened up <code class="highlighter-rouge">serverless.yml</code> and removed all of the comments, so now we have something like this (I added some annotations):
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre><td class="code"><pre># serverless.yml

service: business-cardistry # Name of our service

provider:
  name: aws # AWS is our FaaS provider
  runtime: nodejs6.10 # The language our functions are using

functions:  # This is our list of functions
  hello:  # We have a function named hello
    handler: handler.hello  # references a function called hello in handler.js
</pre></table>
</div>
</div>
<p>Let’s modify our <code class="highlighter-rouge">hello</code> function by renaming it to <code class="highlighter-rouge">pdf</code> and connecting it to an API event. We do that by modifying our <code class="highlighter-rouge">functions</code> section to look like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre><td class="code"><pre>functions:
  pdf:
    handler: handler.pdf
    events:
      - http:
          path: pdf
          method: post
</pre></table>
</div>
</div>
<p>As you can see, we added an <code class="highlighter-rouge">events</code> level to our <code class="highlighter-rouge">hello</code> section. We set the path to <code class="highlighter-rouge">pdf</code> and the method to <code class="highlighter-rouge">post</code>. This means we can trigger this event by sending a post request to <em>some-url-goes-here/pdf</em>. It looks a lot like a routing system in a traditional web framework, but again, it’s being handled at the infrastructure level.
<p>Now, let’s take a look at <code class="highlighter-rouge">handler.js</code>.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre><td class="code"><pre># handler.js
'use strict';

module.exports.hello = (event, context, callback) =&gt; {
  const response = {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Go Serverless v1.0! Your function executed successfully!',
      input: event,
    }),
  };

  callback(null, response);
};
</pre></table>
</div>
</div>
<p>Again, let’s modify it by changing <code class="highlighter-rouge">hello</code> to <code class="highlighter-rouge">pdf</code>. Let’s also change the body to only return the message. Now, the file should look like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre><td class="code"><pre>'use strict';

module.exports.pdf = (event, context, callback) =&gt; {
  const response = {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Go Serverless v1.0! Your function executed successfully!',
    }),
  };

  callback(null, response);
};
</pre></table>
</div>
</div>
<p>Alright, now <code class="highlighter-rouge">serverless.yml</code> defines a function called <code class="highlighter-rouge">pdf</code>, which is connected to the <code class="highlighter-rouge">pdf</code> function in <code class="highlighter-rouge">handler.js</code>. We now should have everything we need to deploy and send a request.
<h3 id="deploy-and-send-a-test-request">Deploy and Send a Test Request</h3>
<p>There actually isn’t any straightforward way to run your serverless script locally, so we actually need to deploy it to test it out.
<p>You can deploy it with the command:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>serverless deploy -s dev
</pre></table>
</div>
</div>
<p>The <code class="highlighter-rouge">-s dev</code> part tells it to set the stage to dev. The stage is how we differentiate production code from development code. We will deploy it to the production stage when everything is working.
<p>You should see something like this when you deploy:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre><td class="code"><pre>$ serverless deploy -s dev
Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (327 B)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
...............................
Serverless: Stack update finished...
Service Information
service: business-cardistry
stage: dev
region: us-east-1
stack: business-cardistry-dev
api keys:
  None
endpoints:
  POST - https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf
functions:
  pdf: business-cardistry-dev-pdf
</pre></table>
</div>
</div>
<p>There is the URL for our endpoint. Let’s try it out!
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre><td class="code"><pre>$ curl -X POST https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf
{"message":"Go Serverless v1.0! Your function executed successfully!"}
</pre></table>
</div>
</div>
<p>It works! I’m still blown away by how easy that is.
<h3 id="set-up-an-s3-bucket">Set Up an S3 Bucket</h3>
<p>Because we are going to be sending back a link that the user can use to download their business card, we need to upload the PDFs to S3. Let’s quickly set up an S3 bucket with the proper permissions.
<p>First, let’s talk about permissions. Lambdas have an execution role that they assume when they run. The permissions the execution role has will determine which AWS services (like S3) our Lambda function can access.
<p>By default, every new Lambda function gets its own new role, we need to first get the Role ARN of the new role that was created for our function. The Role ARN is the ID of the role that we will use to give that role access to S3.
<p>Later, when we deploy a production function, we will change the execution role of the production function to match dev role which will give the production function the same access that the dev function has.
<p>But first, we need that Role ARN.
<p>Log in to your AWS console and go to the Lambda service.
<p>You should see our function on the list. Go ahead and click it.
<p><img src="https://cdn.filestackcontent.com/HjebSOAcRXqJCPhLBkmo" alt="skitch.png" />
<p>Scroll down to the section that says “Execution Role” and you should see the role that is currently selected. Don’t change it — we just needed to see the name of the role.
<p><img src="https://cdn.filestackcontent.com/C5ZeY2CVTzGROwYIuVnQ" alt="skitch.png" />
<p>Now, get the Role ARN by going to the IAM service in the AWS console, click on “Roles” in the sidebar, and select the role for the function. You should see the “Role ARN” at the top of the role page.
<p>Or, if you have the AWS CLI installed, you can get the Role ARN by running this command:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>aws iam get-role --role-name name-of-role
</pre></table>
</div>
</div>
<p>The Role ARN should look something like this:
<p><code class="highlighter-rouge">arn:aws:iam::525814828111:role/business-cardistry-dev-us-east-1-lambdaRole</code>
<p>Now, go to the S3 service.
<p>Click “Create Bucket.”
<p><img src="https://cdn.filestackcontent.com/nJLo9YqTFmVxKwzAlIrA" alt="skitch.png" />
<p>Give the bucket a name but leave everything else at its default value by clicking “Next,” “Next,” “Next,” “Create Bucket.”
<p><img src="https://cdn.filestackcontent.com/3PGjDW4tTFedF6jGQQQM" alt="skitch.png" />
<p>Then, click on your newly created bucket.
<p>Select the Permissions tab, then Bucket Policy.
<p><img src="https://cdn.filestackcontent.com/tMCgzh96Tv2Y6TsODsZv" alt="skitch.png" />
<p>Paste this into the editor. Be sure to replace <em>role-goes-here</em> with the Role ARN.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre><td class="code"><pre><span class="p">{</span><span class="w">
    </span><span class="nt">"Version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2012-10-17"</span><span class="p">,</span><span class="w">
    </span><span class="nt">"Statement"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nt">"Sid"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AllowPutForAllS3TestfilesLambda"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"Effect"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Allow"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"Principal"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
                </span><span class="nt">"AWS"</span><span class="p">:</span><span class="w"> </span><span class="s2">"role-goes-here"</span><span class="w">
            </span><span class="p">},</span><span class="w">
            </span><span class="nt">"Action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"s3:*"</span><span class="p">,</span><span class="w">
            </span><span class="nt">"Resource"</span><span class="p">:</span><span class="w"> </span><span class="s2">"arn:aws:s3:::business-cardistry/*"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table>
</div>
</div>
<p>Alright, this policy allows our custom role to perform all S3 actions on our new S3 bucket. S3 should be good to go!
<h3 id="code-our-function">Code Our Function</h3>
<p>Okay, now we can get to coding. Let’s make our <code class="highlighter-rouge">pdf</code> function. It needs to receive some HTML, process it into a PDF file buffer, then then upload that buffer to S3.
<p>Let’s initialize npm and add some dependencies.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre><td class="code"><pre>$ npm init -y
$ npm install --save html-pdf aws-sdk shortid
</pre></table>
</div>
</div>
<p>The <code class="highlighter-rouge">html-pdf</code> library we are using requires the program <code class="highlighter-rouge">phantomjs</code> to be available as an executable binary. Normally, if we were running this script on a server, we would just install <code class="highlighter-rouge">phantomjs</code> on the server. Because this is serverless, we need to make sure that the runtime context has access to the <code class="highlighter-rouge">phantomjs</code> executable binary.
<p>The way I handled this was to <a href="http://phantomjs.org/download.html">download the binary</a> and put it into a <code class="highlighter-rouge">bin</code> folder in the project root.
<p>Then, I made sure to add this to the serverless.yml file:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre><td class="code"><pre>package:
  include:
    - bin/phantomjs
</pre></table>
</div>
</div>
<p>Now, when the function is deployed, it grabs that binary and uploads it while preserving its permissions and making it available in the runtime environment of the function.
<p>Okay. Let’s get to the code. Here is what my <code class="highlighter-rouge">pdf</code> function looks like:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre><td class="code"><pre>'use strict';

const pdf = require('html-pdf');
const path = require('path');
const AWS = require('aws-sdk');
const shortid = require('shortid');

module.exports.pdf = (event, context, callback) =&gt; {
  const html = event.body;
  pdf.create(html, {
    height: '200px',
    width: '350px',
    phantomPath: path.resolve(process.env.LAMBDA_TASK_ROOT, 'bin/phantomjs'),
  }).toBuffer((err, buffer) =&gt; {
    if (err) return console.log(err);

    const fileKey = `cards/${shortid.generate()}.pdf`;
    const bucket = 'business-cardistry';

    const s3 = new AWS.S3();
    s3.putObject({
      Bucket: bucket,
      Key: fileKey,
      Body: buffer,
      ACL: 'public-read'
    },function (resp) {
      const fileUrl = s3.getSignedUrl('getObject', {
        Bucket: bucket,
        Key: fileKey,
        Expires: 60,
      });

      callback(null, {
        statusCode: 200,
        headers: {
          'Content-Type' : 'application/json',
          'Access-Control-Allow-Origin' : '*',
        },
        body: JSON.stringify({ fileUrl }),
      });
    });
  });
};
</pre></table>
</div>
</div>
<p>I’m not going to go into the code too deeply, but it takes the body of the request and uses it to generate a PDF buffer. It then uploads the buffer to S3 and returns a signed URL for the uploaded object.
<p>You see the line that says <code class="highlighter-rouge">path.resolve(process.env.LAMBDA_TASK_ROOT, 'bin/phantomjs')</code>? This is how we reference that phantomjs executable binary.
<p>You’ll notice that we don’t need to specify any AWS credentials. It automatically gets the credentials from the execution role.
<h3 id="testing-and-final-deployment">Testing and Final Deployment</h3>
<p>Since this endpoint simply receives HTML and returns a filepath, we should still be able to test it with a curl command. First, let’s deploy to dev again.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>serverless deploy -s dev
</pre></table>
</div>
</div>
<p>The above deploy command will deploy the whole project. To deploy only one function, you can use the command:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>serverless deploy function -f pdf -s dev
</pre></table>
</div>
</div>
<p>If you run into any errors, you can check the logs for the <code class="highlighter-rouge">pdf</code> function with this command:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>logs -f pdf -s dev
</pre></table>
</div>
</div>
<p>Now we can test it by sending another curl request with a string of HTML
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre><td class="code"><pre>$ curl -d '&lt;h1&gt;Hello PDF!&lt;/h1&gt;' -X POST https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf
{"fileUrl":"https://business-cardis...j2hJHSBQ%3D%3D"}
</pre></table>
</div>
</div>
<p>It works! When I paste in the fileUrl link into a browser, it downloads a PDF that looks like this:
<p><img src="https://cdn.filestackcontent.com/VKbRNpBATGGvLVGmV9W7" alt="SJ5Orpb7M-1.jpg" />
<p>Which is exactly what we expect.
<p>So now, let’s deploy in production!
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre><td class="code"><pre>$ serverless deploy -s production
Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Creating Stack...
Serverless: Checking Stack create progress...
.....
Serverless: Stack create finished...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (35.56 MB)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
..............................
Serverless: Stack update finished...
Service Information
service: business-cardistry
stage: production
region: us-east-1
stack: business-cardistry-production
api keys:
  None
endpoints:
  POST - https://8103v1xvqk.execute-api.us-east-1.amazonaws.com/production/pdf
functions:
  pdf: business-cardistry-production-pdf
</pre></table>
</div>
</div>
<p>Now, this created a whole new function in Lambda, so remember all of that talk about execution roles? We need to change the execution role of the production function to match the role of the dev function. That way the production function will have access to S3 as well..
<p>So go back to the Lambda page in AWS, click on the new production function that was just created, and change the Execution Role to the dev role:
<p><img src="https://cdn.filestackcontent.com/xji2HYMZQySyeb74aIL7" alt="skitch.png" />
<p>Once that’s done, we can double check the production endpoint.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre><td class="code"><pre>$ curl -d '&lt;h1&gt;Hello PDF!&lt;/h1&gt;' -X POST https://8103v1xvqk.execute-api.us-east-1.amazonaws.com/production/pdf
{"fileUrl":"https://business-cardis...j2hJHSBQ%3D%3D"}
</pre></table>
</div>
</div>
<p>Aaaaaand it works! Now after modifying the request URL in my React code, my app is complete!
<p>Be sure to check out <a href="http://cardistry.nmajor.com/">cardistry.nmajor.com</a> to see it in action.
<p>I know this was just a simple example with one endpoint, but this same process could be used to build dozens of endpoints for almost any app. I hope this gives you a good idea of what’s possible with serverless, and how easy and powerful it can be!
<h2 id="limitations-and-drawbacks-of-serverless">Limitations and Drawbacks of Serverless</h2>
<p>As awesome as serverless is, there are some limitations and drawbacks:
<p><strong>Latency</strong><br />
Although AWS Lambda is designed to execute functions in milliseconds, you do have some added latency when using serverless. However, we are talking about a few hundred added milliseconds. For most web applications, it’s not going to be an issue, but if latency is really important for your project, it’s something you are going to want to consider.
<p><strong>Vendor Lock-in</strong>
Because serverless relies so heavily on the infrastructure and the supporting services, but you may need to re-write large parts of your application to move it to a different provider.
<p><strong>Black Box</strong><br />
Many of the parts of your application are out of your control, so when things go wrong or if you hit an edge use-case with your app, you have little control over your ability to resolve it yourself.
<p><strong>New Tech</strong><br />
Serverless is still in its infancy, so, as with any new technology, great care should be used when deciding whether or not to jump on the bandwagon early.
<h2 id="conclusion">Conclusion</h2>
<p>I believe serverless is the next big thing in web development. So much in web development is the same. Every framework solves many of the same problems in the same way. Serverless is solving those problems at the infrastructural level, leaving you free to work on the important and different parts of your App.
<p>Combine that with cost and scalability benefits, and the fact that there are so many amazing front-end frameworks like React, and the days of traditional back-end frameworks are numbered.
<h2 id="other-resources">Other Resources:</h2>
<ul>
 <li><a href="https://serverless-stack.com/">serverless-stack.com</a> — A comprehensive tutorial on building and deploying full-stack apps using Serverless and React on AWS.
 <li><a href="https://serverless.com/">serverless.com</a> — Great documentation, community, and other resources.
</ul>
</article>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'nmajor';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
           <footer>
    <span>A blog filled with adventures in tech</span>
    <span>written by Nicholas Major</span>
</footer>
       </div>
<script type="text/javascript" src="/assets/js/theme.js"></script>
<script type="text/javascript" src="/assets/js/barefoot.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-48130330-1', 'auto');
      ga('send', 'pageview');
    </script>
    
