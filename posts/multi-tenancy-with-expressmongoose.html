<!DOCTYPE html>
<html lang="en">
   <head>
       <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<title>Multi Tenancy with Express/Mongoose &#9642; NMajor Blog</title>
<!--
<meta name="description" content="Multi tenant apps are apps where multiple users share the same database but their data is isolated from one another. This can basically describe almost any app with multiple users. For example users can often only see and change their own data. However, personally, I define multi tenant apps as...">
-->
<meta name="description" content="A blog filled with adventures in tech">
<meta name="keywords" content="mongoose, express, node, javascript">
<link rel="canonical" href="/posts/multi-tenancy-with-expressmongoose">
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Multi Tenancy with Express/Mongoose" />
<meta name="twitter:description" content="A blog filled with adventures in tech" />
<meta name="twitter:image" content="" />
<meta name="author" content="">
<link rel="author" href="">
<meta property="og:locale" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="Multi Tenancy with Express/Mongoose">
<meta property="og:description" content="A blog filled with adventures in tech">
<meta property="og:url" content="/posts/multi-tenancy-with-expressmongoose">
<meta property="og:site_name" content="NMajor Blog">
<link rel="stylesheet" href="/assets/vendor/normalize-css/normalize.css">
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700,700i">
<style>
    html {
      font-family: "Open Sans", "Helvetica Neue", sans-serif;
    }
</style>
<link rel="stylesheet" href="/assets/css/bf.css">
   <body>
       <div class="wrapper" id="blep">
          <header>
   <div class="menu">
     <div class="logo">
        <img src="/uploads/me4.jpg" />
        <a href="/">NMajor Blog</a>
     </div>
       <ul>
           <li><a href="/about">About</a>
           <li><a href="/projects">Projects</a>
           <li><a href="/archive">Archive</a>
       </ul>
   </div>
   <div class="social">
     <ul>
       <li>
            <a href="https://github.com/nmajor" target="_blank" class="smaller">
              <span class="icon-github"></span>
            </a>
       <li>
            <a href="https://twitter.com/_nmajor" target="_blank" class="smaller">
              <span class="icon-twitter"></span>
            </a>
       <li>
            <a href="https://linkedin.com/in/nmajor" target="_blank" class="smaller">
              <span class="icon2-linkedin"></span>
            </a>
       <li>
            <a href="http://blog.nmajor.com" target="_blank" class="smaller">
              <span class="icon2-globe"></span>
            </a>
       <li>
            <a href="https://instagram.com/_nmajor" target="_blank" class="smaller">
              <span class="icon2-instagram"></span>
            </a>
       <li>
            <a href="/feed.xml" target="_blank">
                <span class="icon-rss_feed"></span>
            </a>
     </ul>
   </div>
</header>
<article class="post">
 <div class="post-title-container
  no-hero-margin
  ">
    <!--Post hero image source-->
   <div class="heading-container ">
     <h1>
          Multi Tenancy with Express/Mongoose
     </h1>
      <span class="published-at">Published Oct 3, 2018</span>
      &#9642;
      <span class="post-tags">
            <a href="/tag/mongoose">#mongoose</a>
            <a href="/tag/express">#express</a>
            <a href="/tag/node">#node</a>
            <a href="/tag/javascript">#javascript</a>
      </span>
          <a href="/posts/multi-tenancy-with-expressmongoose" title="Multi Tenancy with Express/Mongoose"><img class="hero-image" src="/uploads/2018/10/06/Multi-tenant.png" /></a>
   </div>
 </div>
   <p>Multi tenant apps are apps where multiple users share the same database but their data is isolated from one another. This can basically describe almost any app with multiple users. For example users can often only see and change their own data.
<p>However, personally, I define multi tenant apps as having a layer of data isolation above the level of the user. For example you could have a data model called an <code class="highlighter-rouge">organization</code> and the the user can only see and interact with the data related to that organization.
<p class="lead">
<p>Adding this kind of layer to apps is really useful and powerful and can really level up some apps.
<p>The most important thing with multi tenant apps is that the data isolation must be perfect. If a user ever sees data not related to their tenant, it can result it a huge loss of customer trust especially these days when user data is such a hot issue.
<p>We should NOT rely on developers writing queries and logic to keep this data isolation, so the best thing to do is to tackle this at a high level with powerful patterns.
<p>Here’s a possible implementation:
<p>The plan:
<ul>
 <li><strong>Continuation-Local Storage</strong> - Use <a href="">this library</a> to easily give every function access to the current tenant at all times.
 <li><strong>Express Middleware</strong> - Add express middleware that will tell set the current tenent for every request.
 <li><strong>Mongoose Discriminator</strong> - For every tenant create an on-the-fly discriminator model, so all actions performed by the model are in the context of the current tenant.
 <li><strong>Model Wrapper</strong> - Add a wrapper around Mongoose models so that every time that model is used it actually gets a different version of the model specific to the current tenant.
</ul>
<p>I’m assuming you have a basic understanding of express and mongoose.
<h3 id="continuation-local-storage">Continuation-Local Storage</h3>
<p>I recently found this great library called <a href="https://github.com/othiym23/node-continuation-local-storage" title="https://github.com/othiym23/node-continuation-local-storage">node-continuation-local-storage</a>. Basically you can think of most things in javascript as a chain of functions calling functions. What this library does is lets you define variables at the beginning of the function chain, and then every function further down the chain has access to those variables.
<p>The first thing we’ll do is set this library up with express. We do that by first binding the context using an express middleware function, this gives continuous-local-storage a namespace and context to store our variables.
<p>Lets create a file called <code class="highlighter-rouge">lib/storage.js</code> and create an express middleware function to bind the storage context as well as a few exportable getter and setter functions for our <code class="highlighter-rouge">tenantId</code> variable.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre><td class="code"><pre>// lib/storage.js
import { createNamespace } from 'continuation-local-storage';

const namespaceName = 'request';
const ns = createNamespace(namespaceName);

export function bindCurrentNamespace(req, res, next) {
  ns.bindEmitter(req);
  ns.bindEmitter(res);

  ns.run(() =&gt; {
    next();
  });
}

export function setCurrentTenantId(tenantId) {
  return ns.set('tenantId', tenantId);
}

export function getCurrentTenantId() {
  return ns.get('tenantId');
}
</pre></table>
</div>
</div>
<p>Now inside your express bootstrap file, usually called <code class="highlighter-rouge">app.js</code> we add the <code class="highlighter-rouge">bindCurrentNamespace</code> middleware.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre><td class="code"><pre>// app.js

import { bindCurrentNamespace } from 'lib/storage';

app.use(bindCurrentNamespace);
</pre></table>
</div>
</div>
<p>This creates a context that every express request can use.
<p>Next we’ll add another middleware function that will use our <code class="highlighter-rouge">setCurrentTenantId</code> function to set that data for every other function in the chain.
<h3 id="express-middleware">Express Middleware</h3>
<p>No here is where you’ll probably want to tie into any existing authentication system you have. Basically we need to someone figure out which user each request comes from.
<p>Some of the most common approaches here is to connect it with a session or use a bearer token with each request. But this is one area where many people will have different implementations.
<p>We nee to figure out which user the request is connected to, and once we have the user, you should be able to tell which tenant the user belongs to:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre><td class="code"><pre>// app.js

import { bindCurrentNamespace, setCurrentTenantId } from 'lib/storage';

app.use(bindCurrentNamespace);
app.use((req, res, next) =&gt; {
  // Get current user from session or token
  const user = req.user
  
  // Get current tenant from user here
  // Make sure its a string
  const tenantId = user.organization._id.toString()
  
  setCurrentTenantId('tenantId', tenantId);
  next();
});
</pre></table>
</div>
</div>
<p>There you have it. Now every function for every request will have access to the current tenant of the user making the request. We’ll next use this behavior to bind our models to the tenant context.
<h3 id="mongoose-discriminator">Mongoose Discriminator</h3>
<p>So here is where the magic happens. Lets create a new file called <code class="highlighter-rouge">lib/multiTenant.js</code> this file is going to export some higher order functions that will wrap every model with a discriminator based on the tenant id.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre><td class="code"><pre>// lib/multiTenant.js

import mongoose, { Schema } from 'mongoose';
import { getCurrentTenantId } from './storage';

export function tenantModel(name, schema, options) {
  return (props = {}) =&gt; {
    schema.add({ tenantId: String });
    const Model = mongoose.model(name, schema, options);

    const { skipTenant } = props;
    if (skipTenant) return Model;

    Model.schema.set('discriminatorKey', 'tenantId');

    const tenantId = getCurrentTenantId();
    const discriminatorName = `${Model.modelName}-${tenantId}`;
    const existingDiscriminator = (Model.discriminators || {})[discriminatorName];
    return existingDiscriminator || Model.discriminator(discriminatorName, new Schema({}));
  };
}

export function tenantlessModel(name, schema, options) {
  return () =&gt; mongoose.model(name, schema, options);
}
</pre></table>
</div>
</div>
<p>You’ll notice we have two exported higher order functions. If you’re unfamiliar with <a href="https://eloquentjavascript.net/05_higher_order.html" title="https://eloquentjavascript.net/05_higher_order.html">higher order functions</a>, they are basically just functions that return other functions. Its a very powerful and often used pattern in javascript.
<p>The function <code class="highlighter-rouge">tenantlessModel</code> is basically just a passthrough function. We can use this function on any model that should not be tenant-isolated. One of the main examples of this is our tenant model itself which we have been calling <code class="highlighter-rouge">organization</code>. So our <code class="highlighter-rouge">organization</code> model will use this function.
<p>The other function is where all the magic happens. <code class="highlighter-rouge">tenantModel</code> exports another function. And that function returns a modified mongoose model or discriminator.
<p>Lets break down the code section by section:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre><td class="code"><pre>schema.add({ [tenantKey]: String });
const Model = mongoose.model(name, schema, options);
</pre></table>
</div>
</div>
<p>In this line we’re just adding a new attribute to the model schema to hold our <code class="highlighter-rouge">tenantId</code>.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre><td class="code"><pre>const { skipTenant } = props;
if (skipTenant) return Model;
</pre></table>
</div>
</div>
<p>This is just a useful feature. This allows us to easily bypass our tenant isolation whenever we want. I’ve found this particularly useful in testing. But also for things like looking up the user during authentication when its important to be able to search for all users in the database.
<p>But this makes it so the norm is the tenant isolation, and we have to explicitly override it if we want access to all the models in the database.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>Model.schema.set('discriminatorKey', 'tenantId');
</pre></table>
</div>
</div>
<p>This is pretty basic, we’re just telling the model to use the field <code class="highlighter-rouge">'tenantId'</code> as the discriminator key.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre><td class="code"><pre>const tenantId = getCurrentTenantId();
const discriminatorName = `${Model.modelName}-${tenantId}`;
const existingDiscriminator = (Model.discriminators || {})[discriminatorName];
return existingDiscriminator || Model.discriminator(discriminatorName, new Schema({}));
</pre></table>
</div>
</div>
<p>Here is where we actually build a new discriminator based on the current tenant.
<p>Remember discriminators are basically just augmented mongoose models. The common use case is when you want to simulate model inheritance and basically have one model be the same as another but with extra behavior. The discriminator name is the name of the new augmented model. We’re sort of hacking this feature for its built in data isolation.
<p>We’re basically telling mongoose that there will be a different version of each model for each tenant. So if a user belongs to the tenant with the id of <code class="highlighter-rouge">123456</code> and we want to find all the documents in a model called <code class="highlighter-rouge">page</code> then we’re not looking up all the <code class="highlighter-rouge">page</code>s we’re looking up all the <code class="highlighter-rouge">page-123456</code>s.
<p>That is why we have to set the model name to <code class="highlighter-rouge">${Model.modelName}-${tenantId}</code> because we cant have multiple models with the same name.
<p>Then its important to check if the model name already exists so we don’t end up creating multiple versions of the same discriminator. Also mongoose will yell at you if you try. So that is what this line is about:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>const existingDiscriminator = (Model.discriminators || {})[discriminatorName];
</pre></table>
</div>
</div>
<h3 id="model-wrapper">Model Wrapper</h3>
<p>So now that we have these higher order functions we have to user them to wrap our existing mongoose models. This is actually pretty easy. Here are a couple examples:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre><td class="code"><pre>// models/page.js
import { tenantModel } from '../lib/multiTenant';

const PageSchema = new Schema({
  title: String,
  body: String,
});

export default tenantModel('page', PageSchema);
</pre></table>
</div>
</div>
<p>And:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre><td class="code"><pre>// models/user.js
import { tenantModel } from '../lib/multiTenant';

const UserSchema = new Schema({
  name: String,
  email: String,
});

export default tenantModel('user', UserSchema);
</pre></table>
</div>
</div>
<p>You’ll notice that its exactly the same as making and exporting a regular mongoose model except instead of exporting <code class="highlighter-rouge">mongoose.model</code> we are exporting our own <code class="highlighter-rouge">tenantModel</code> function.
<p>Then for models that you want to live outside the tenant isolation you can do this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9</pre><td class="code"><pre>// models/organization.js

import { tenantlessModel } from '../lib/multiTenant';

const OrganizationSchema = new Schema({
  name: String,
});

export default tenantlessModel('organization', OrganizationSchema);
</pre></table>
</div>
</div>
<p>Since the <code class="highlighter-rouge">tenantlessModel</code> is just a passthrough, its not totally necessary. But I chose to do it because as you will see below, our usage of higher order functions changes how we actually use our models in the rest of our code. So the <code class="highlighter-rouge">tenantlessModel</code> function makes the usage standardized for all our models regardless of if they are isolated based on the current tenant.
<h3 id="usage">Usage</h3>
<p>Now this does change how we actually use our models in the rest of our code. Because our default export in our models are higher order functions, we have to execute the returned function before we use each model.
<p>For example we can NO LONGER DO THIS:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>Page.find({})
</pre></table>
</div>
</div>
<p>Instead we have to do this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>Page().find({})
</pre></table>
</div>
</div>
<p>But this actually turns out to be pretty useful. Remember that <code class="highlighter-rouge">skipTenant</code> thing before? We can actually pass options into our model function like <code class="highlighter-rouge">skipTenant</code> to customize our access to the model even further.
<p>For example to search EVERY user in our database, not just the ones associated with our current tenant we can do this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>User({ skipTenant: true }).find({ _id: '123456' })
</pre></table>
</div>
</div>
<h3 id="benefits">Benefits</h3>
<p>You’ll notice that this implementation really doesn’t require a lot of code.
<p>It also gives us a lot of useful abstraction layers to add extra behavior to our models.
<p>But, whats really great about this approach is that because we are always dealing with tenant isolated versions of every model, then any model that is created by a logged in user is <strong>automatically</strong> assigned to the correct tenant.
<p>And all queries and lookups are <strong>automatically</strong> isolated to the tenant.
<p>And it is basically nearly impossible for a user to view, list, update, create, or delete any model outside their own tenant because any mongoose function used to perform those actions is isolated to the users tenant from the get go.
<p>We don’t have to rely on developers coding correct logic. And we can easily add other authentication logic on top of it and be confident our tenant isolation is secure.
<h3 id="extra-customization">Extra Customization</h3>
<p>Because our higher order functions have access to the schema of each model, we can do lots of things to our models. For example we can add new middleware to any model that has a tenant. Here’s just one simple example of making sure every <code class="highlighter-rouge">tenantModel</code> has a tenant using the before save mongoose middleware:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre><td class="code"><pre>export function tenantModel(name, schema, options) {
  return (props = {}) =&gt; {
    schema.add({ tenantId: String });

    schema.pre('save', function (next) {
      if (!this.tenantId) {
        const defaultTenantId = // find tenant
        this.tenantId = defaultTenantId;
      }
    });
  
    const Model = mongoose.model(name, schema, options);

    // ...
  };
}
</pre></table>
</div>
</div>
<p>You can also insert some authorization logic in here. For example you could set the current user using Continuation-Local Storage and then if the user is an admin, return the unmodified model, like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre><td class="code"><pre>import { getCurrentTenantId, getCurrentUser } from './storage';

export function tenantModel(name, schema, options) {
  return (props = {}) =&gt; {
    schema.add({ tenantId: String });
    const Model = mongoose.model(name, schema, options);

    if (getCurrentUser().isAdmin()) return Model;

	// ...
  };
}
</pre></table>
</div>
</div>
<h3 id="conclusion">Conclusion</h3>
<p>I hope this at least gives you some ideas of how to add a solid multi-tenant layer in your express/mongoose app.
<p>As always, if you notice any problems in my code or flaws in my approach, please let me know. I’m always looking to learn and improve.
<p>Thanks for reading!
<p>Thanks to these libraries for inspiration:
<ul>
 <li><a href="https://www.npmjs.com/package/mongoose-multitenant" title="https://www.npmjs.com/package/mongoose-multitenant">https://www.npmjs.com/package/mongoose-multitenant</a>
 <li><a href="https://www.npmjs.com/package/mongoose-multitenant" title="https://www.npmjs.com/package/mongoose-multitenant">https://www.npmjs.com/package/mongoose-multitenancy</a>
</ul>
</article>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'nmajor';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
           <footer>
    <span>A blog filled with adventures in tech</span>
    <span>written by Nicholas Major</span>
</footer>
       </div>
<script type="text/javascript" src="/assets/js/theme.js"></script>
<script type="text/javascript" src="/assets/js/barefoot.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-48130330-1', 'auto');
      ga('send', 'pageview');
    </script>
    
