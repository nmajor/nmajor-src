<!DOCTYPE html>
<html lang="en">
   <head>
       <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
<title>Simple Object Storage in Redis (Node.js) &#9642; NMajor Blog</title>
<!--
<meta name="description" content="Redis is a simple key value store and is highly optimized for fast reads and writes. I found myself in a situation where I wanted to offload some app task logging from our document store (mongoDB) to redis. There are a few important things to consider when making this kind...">
-->
<meta name="description" content="A blog filled with adventures in tech">
<meta name="keywords" content="node, redis, javascript">
<link rel="canonical" href="/posts/simple-object-storage-in-redis-and-node">
<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Simple Object Storage in Redis (Node.js)" />
<meta name="twitter:description" content="A blog filled with adventures in tech" />
<meta name="twitter:image" content="" />
<meta name="author" content="">
<link rel="author" href="">
<meta property="og:locale" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="Simple Object Storage in Redis (Node.js)">
<meta property="og:description" content="A blog filled with adventures in tech">
<meta property="og:url" content="/posts/simple-object-storage-in-redis-and-node">
<meta property="og:site_name" content="NMajor Blog">
<link rel="stylesheet" href="/assets/vendor/normalize-css/normalize.css">
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700,700i">
<style>
    html {
      font-family: "Open Sans", "Helvetica Neue", sans-serif;
    }
</style>
<link rel="stylesheet" href="/assets/css/bf.css">
   <body>
       <div class="wrapper" id="blep">
          <header>
   <div class="menu">
     <div class="logo">
        <img src="/uploads/me4.jpg" />
        <a href="/">NMajor Blog</a>
     </div>
       <ul>
           <li><a href="/about">About</a>
           <li><a href="/projects">Projects</a>
           <li><a href="/archive">Archive</a>
       </ul>
   </div>
   <div class="social">
     <ul>
       <li>
            <a href="https://github.com/nmajor" target="_blank" class="smaller">
              <span class="icon-github"></span>
            </a>
       <li>
            <a href="https://twitter.com/_nmajor" target="_blank" class="smaller">
              <span class="icon-twitter"></span>
            </a>
       <li>
            <a href="https://linkedin.com/in/nmajor" target="_blank" class="smaller">
              <span class="icon2-linkedin"></span>
            </a>
       <li>
            <a href="http://blog.nmajor.com" target="_blank" class="smaller">
              <span class="icon2-globe"></span>
            </a>
       <li>
            <a href="https://instagram.com/_nmajor" target="_blank" class="smaller">
              <span class="icon2-instagram"></span>
            </a>
       <li>
            <a href="/feed.xml" target="_blank">
                <span class="icon-rss_feed"></span>
            </a>
     </ul>
   </div>
</header>
<article class="post">
 <div class="post-title-container
  no-hero-margin
  ">
    <!--Post hero image source-->
   <div class="heading-container ">
     <h1>
          Simple Object Storage in Redis (Node.js)
     </h1>
      <span class="published-at">Published Oct 5, 2018</span>
      &#9642;
      <span class="post-tags">
            <a href="/tag/node">#node</a>
            <a href="/tag/redis">#redis</a>
            <a href="/tag/javascript">#javascript</a>
      </span>
          <a href="/posts/simple-object-storage-in-redis-and-node" title="Simple Object Storage in Redis (Node.js)"><img class="hero-image" src="/uploads/2018/10/06/object Storage.png" /></a>
   </div>
 </div>
   <p><a href="https://redis.io/" title="https://redis.io/">Redis</a> is a simple key value store and is highly optimized for fast reads and writes. I found myself in a situation where I wanted to offload some app task logging from our document store (mongoDB) to redis.
<p>There are a few important things to consider when making this kind of change.
<p class="lead">
<p><strong>First</strong> it was important for our use case to have some basic kind of indexing and sorting based on when the document was created.
<p><strong>Second</strong>, since we do a lot of logging, we needed to make sure that all documents clean up after themselves and expire nicely so we don’t run out of space in redis, and we don’t really care about keeping these logs indefinitely.
<p><strong>Third</strong>, our logs are javascript objects, so we needed some kind of customizable serialization/deserialization.
<p><strong>Fourth</strong>, I wanted to have a nice abstraction with predictable model-like behavior like <code class="highlighter-rouge">findOne</code>, <code class="highlighter-rouge">create</code>, <code class="highlighter-rouge">update</code>, and <code class="highlighter-rouge">fromIndex</code>.
<p>So here is a basic solution I came up with.
<p>The plan:
<ul>
 <li><strong>Schema</strong> - Add a schema for <code class="highlighter-rouge">redisModels</code>
 <li><strong>Finding, Creating and Updating</strong> - Use <a href="">redis hashes</a> to store our objects and have functions for adding, finding, and updating.
 <li><strong>Indexing and Sorting</strong> - Use <a href="https://redis.io/topics/data-types#lists" title="https://redis.io/topics/data-types#lists">redis lists</a> (aka ranges) to maintain a sorted list of object keys.
</ul>
<p>I’ll be using the main <a href="https://www.npmjs.com/package/redis" title="https://www.npmjs.com/package/redis">redis node</a> library for this.
<h3 id="schema">Schema</h3>
<p>Here is what our basic schema will look like:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre><td class="code"><pre>const logSchema = {
  namespace: 'logs',
  indexes: [
    {
      getName: () =&gt; 'createdAt',
      shouldIndex: () =&gt; true,
      addNonTenantIndex: () =&gt; true,
      getValue: data =&gt; new Date(data.createdAt).getTime(),
    },
  ],
  attributes: {
    source: { kind: 'string' },
    user: { kind: 'object' },
    body: { kind: 'object' },
    createdAt: { kind: 'time' },
  },
};
</pre></table>
</div>
</div>
<p>As you can see we set information about our <code class="highlighter-rouge">attributes</code>, <code class="highlighter-rouge">indexes</code> and a <code class="highlighter-rouge">namespace</code> that we will use for our redis keys. The <code class="highlighter-rouge">namespace</code> is mostly useful if you plan on storing multiple kinds of objects in redis.
<h3 id="creating">Creating</h3>
<p>We’ll start by creating a new class and constructor inside of a new file called <code class="highlighter-rouge">lib/redis.js</code>. I know this is a bunch of code to dump in all at once, but I’ll break it down afterwards:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74</pre><td class="code"><pre>import shortid from 'shortid';
import _ from 'lodash';

function getRedisClient() {
  // IMPLEMENT YOUR OWN METHOD OF GETTING THE REDIS CLIENT,
}

function expSeconds(days = 30) {
  const secondsPerDay = 86400;
  return days * secondsPerDay;
}

function buildId() { return shortid.generate(); }

const stringify = {
  string: data =&gt; data,
  number: data =&gt; data.toString(),
  date: data =&gt; new Date(data).toISOString(),
  time: data =&gt; new Date(data).toISOString(),
  object: data =&gt; JSON.stringify(data),
};

export default class RedisModel {
  constructor(schema) {
    this.props = {
      schema,
      client: getRedisClient(),
    };
  }

  _buildHashValues(data) {
    const { schema: { attributes } } = this.props;
    const hashValues = [];

    _.each(data, (value, key) =&gt; {
      const type = (attributes[key] || {}).kind;
      const stringValue = stringify[type] ? stringify[type](value) : undefined;
      if (!type || !stringValue) return null;

      return hashValues.push(key, stringValue);
    });

    return _.isEmpty(hashValues) ? undefined : hashValues;
  }

  _buildRedisKey(id) {
    const { schema } = this.props;
    return `${schema.namespace}:${id}`;
  }

  create(data) {
    const { client } = this.props;

    return new Promise((resolve, reject) =&gt; {
      const multi = client.multi();
      const id = buildId();
      const redisKey = this._buildRedisKey(id);

      // Handle the hash values
      const hashValues = this._buildHashValues(data);
      if (hashValues) {
        multi.hmset(redisKey, hashValues);
        multi.hmset(redisKey, 'EX', expSeconds());
        multi.exec((err) =&gt; {
          if (err) return reject(err);

          return resolve({ key: redisKey, _id: id, ...data });
        });
      } else {
        reject(new Error('Empty redis hash data'));
      }
    });
  }
}
</pre></table>
</div>
</div>
<p>First of all you’ll notice I’m using the <a href="">lodash</a> for its useful helper methods, and <a href="https://www.npmjs.com/package/shortid" title="https://www.npmjs.com/package/shortid">shortid</a> to help generate unique ids for our redis keys.
<p>We are using the <code class="highlighter-rouge">multi</code> redis behavior.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre><td class="code"><pre>const multi = client.multi();
// ...
multi.hmset(redisKey, hashValues);
multi.hmset(redisKey, 'EX', expSeconds());
multi.exec((err) =&gt; {
// ...
</pre></table>
</div>
</div>
<p>This allows us to do multiple calls in one redis transaction, and if one of the calls fails, the whole transaction will fail. This reduces the chances that we’ll have stray data being stored in the database.
<p>We’re also using our schema namespace to build a unique redis key for our object.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre><td class="code"><pre>const redisKey = this._buildRedisKey(id);

  _buildRedisKey(id) {
    const { schema } = this.props;
    return `${schema.namespace}:${id}`;
  }
</pre></table>
</div>
</div>
<p>This isn’t totally necessary, and really only useful if you are storing multiple types of objects in redis, but it does give us the ability to do basic fetching redis for all items with the namespace prefix later if we want.
<p>You can see that we’re using a <a href="https://redis.io/topics/data-types#hashes" title="https://redis.io/topics/data-types#hashes">redis hash</a> to store all our object data.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>multi.hmset(redisKey, hashValues);
</pre></table>
</div>
</div>
<p>The <a href="https://redis.io/commands/hmset" title="https://redis.io/commands/hmset">hmset</a> function takes an array of key value pairs. Redis hashes require the values to be strings, so our <code class="highlighter-rouge">_buildHashValues</code> function takes our data and converts it to an array of strings based on the key/value pairs and attribute types in the schema.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre><td class="code"><pre>  _buildHashValues(data) {
    const { schema: { attributes } } = this.props;
    const hashValues = [];

    _.each(data, (value, key) =&gt; {
      const type = (attributes[key] || {}).kind;
      const stringValue = stringify[type] ? stringify[type](value) : undefined;
      if (!type || !stringValue) return null;

      return hashValues.push(key, stringValue);
    });

    return _.isEmpty(hashValues) ? undefined : hashValues;
  }
</pre></table>
</div>
</div>
<p>And it uses our <code class="highlighter-rouge">stringify</code> object as a map for how to convert the different attributes to strings based on the schema. This gives us some granular control over the serialization of each attribute of our objects.
<p>And we’re also setting an expiration for our keys so they dont last forever in our database.
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre><td class="code"><pre>multi.hmset(redisKey, 'EX', expSeconds());
</pre></table>
</div>
</div>
<p>And that handles our ability to create new objects in our redis model.
<h3 id="updating">Updating</h3>
<p>Our update function is very similar to our create:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre><td class="code"><pre>export default class RedisModel {
  // ...
  update(id, data) {
    const { client } = this.props;

    return new Promise((resolve, reject) =&gt; {
      const redisKey = this._buildRedisKey(id);

      // Handle the hash values
      const hashValues = this._buildHashValues(data);
      if (hashValues) {
        client.hmset(redisKey, hashValues, (err) =&gt; {
          if (err) return reject(err);

          return resolve();
        });
      } else resolve();
    });
  }
}
</pre></table>
</div>
</div>
<p>Basically it uses the same <code class="highlighter-rouge">_buildRedisKey</code> function so we only have to deal with the id of the object. Then it basically just does the same <code class="highlighter-rouge">hmset</code> function. Redis will keep any attributes in the hash that are not overwritten.
<h3 id="finding">Finding</h3>
<p>Here’s our find method. This lets us find any object by id and deserialize all the values into their original datatypes based on the schema:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre><td class="code"><pre>const parsify = {
  string: data =&gt; data,
  number: data =&gt; parseInt(data, 10),
  date: data =&gt; new Date(data),
  time: data =&gt; new Date(data),
  object: data =&gt; JSON.parse(data),
};

export default class RedisModel {
  // ...
  _unpackHashValues(data) {
    const { schema: { attributes } } = this.props;
    const obj = {};

    _.each(data, (value, key) =&gt; {
      const type = (attributes[key] || {}).kind;
      if (!type) return null;

      obj[key] = parsify[type](value);
      return null;
    });

    return _.isEmpty(obj) ? undefined : obj;
  }

  findOne(id) {
    const { client } = this.props;

    return new Promise((resolve, reject) =&gt; {
      const redisKey = this._buildRedisKey(id);
      client.hgetall(redisKey, (err, data) =&gt; {
        if (err) return reject(err);

        return resolve({
          key: redisKey,
          _id: id,
          ...this._unpackHashValues(data),
        });
      });
    });
  }
}
</pre></table>
</div>
</div>
<p>Here is where we use a <code class="highlighter-rouge">parsify</code> method to convert our attribute strings into their original data type.
<p>And that handles our finding and deserialization.
<h3 id="indexing-and-sorting">Indexing and Sorting</h3>
<p>Here is the tricky part. Redis, as a key/value store doesnt have any real sense of ordering when it comes to its keys. But its important for our use case to be able to see the most recent logs, and maybe later be able to query date ranges of when the logs were created.
<p>So what we’re going to do is use the redis function <code class="highlighter-rouge">zadd</code> to add the redis key and timestamp for each object into a sorted redis list.
<p>Remember from our schema, indexes look like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre><td class="code"><pre><span class="p">{</span><span class="w">
  </span><span class="err">getName:</span><span class="w"> </span><span class="err">()</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="err">'createdAt',</span><span class="w">
  </span><span class="err">shouldIndex:</span><span class="w"> </span><span class="err">()</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="err">true,</span><span class="w">
  </span><span class="err">getValue:</span><span class="w"> </span><span class="err">data</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="err">new</span><span class="w"> </span><span class="err">Date(data.createdAt).getTime(),</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table>
</div>
</div>
<p><code class="highlighter-rouge">getName</code> is a function because I’ve found it useful to be able to create some indexes that are isolated in different ways. For example I’ve sometimes added indexes that are based on the ID of the user who created the log, this lets me easily get a list of all the user’s most recent indexes. And in that case the <code class="highlighter-rouge">getName</code> looks like this <code class="highlighter-rouge">getName: data =&gt; ('user:'+data.user._id+':createdAt')</code>.
<p><code class="highlighter-rouge">shouldIndex</code> lets us not index any object we want, and <code class="highlighter-rouge">getValue</code> gives us the actual value of the index, so this actually lets us create sorted lists using any different attribute not just createdAt. Just remember that <code class="highlighter-rouge">getValue</code> has to return a number.
<p>Now we modify our <code class="highlighter-rouge">create</code> function to include a <code class="highlighter-rouge">zadd</code> for each index in our schema:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre><td class="code"><pre>_buildIndexName(indexName) {
    const { schema } = this.props;
    return `${schema.namespace}:${indexName}`;
  }

  create(data) {
    const { schema, client } = this.props;

    return new Promise((resolve, reject) =&gt; {
      const multi = client.multi();
      const id = buildId();
      const redisKey = this._buildRedisKey(id);

      // Handle the hash values
      const hashValues = this._buildHashValues(data);
      if (hashValues) {
        multi.hmset(redisKey, hashValues);
        multi.hmset(redisKey, 'EX', expSeconds());

        // Handle indexes
        if (schema.indexes) {
          _.each(schema.indexes, (index) =&gt; {
            if (index.shouldIndex(data)) {
              multi.zadd(this._buildIndexName(index.getName(data)), index.getValue(data), redisKey);
            }
          });
        }

        multi.exec((err) =&gt; {
          if (err) return reject(err);

          return resolve({ key: redisKey, _id: id, ...data });
        });
      } else {
        reject(new Error('Empty redis hash data'));
      }
    });
  }
</pre></table>
</div>
</div>
<p>This inserts the <code class="highlighter-rouge">redisKey</code> of each object into a sorted list based on the createdAt timestamp of the object.
<p>Now we can easily retrieve the top objects from any index with a function like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre><td class="code"><pre>export default class RedisModel {
  // ...
  _clearOldIndexes(indexName) {
    const { client, schema } = this.props;
    return new Promise((resolve, reject) =&gt; {
      const now = new Date().getTime();
      const secondsPerDay = 86400;
      const args = [
        this._buildIndexName(schema, indexName),
        (now + (expSeconds() - secondsPerDay) * 1000),
        '-inf',
      ];

      client.zremrangebyscore(args, (err, results) =&gt; {
        if (err) return reject(err);

        return resolve(results);
      });
    });
  }

  _getIndexedIds(indexName, offset, limit) {
    const { client } = this.props;

    return this._clearOldIndexes(indexName)
      .then(() =&gt; new Promise((resolve, reject) =&gt; {
        const args = [indexName, '+inf', '-inf', 'LIMIT', offset || 0, limit || 20];

        client.zrevrangebyscore(args, (err, results) =&gt; {
          if (err) return reject(err);

          return resolve(results);
        });
      }));
  }

  fromIndex(indexName) {
    return this._getIndexedIds(indexName, undefined, 250)
      .then(results =&gt; Promise.all(results.map(result =&gt; this.findOne(result))));
  }
}
</pre></table>
</div>
</div>
<p>Notice that inside <code class="highlighter-rouge">_getIndexedIds</code> we first <code class="highlighter-rouge">_clearOldIndexes</code>. This is because redis does not allow us to set expiration times for entries inside of a list so I get around this by first removing all entries that are expired before actually getting a list of all the entries in the list.
<p>Then it gets a list of all the ids using the <a href="">zrangebyscore</a> function. Then it converts each one into its full object using the <code class="highlighter-rouge">findOne</code> function that we already made.
<h3 id="usage">Usage</h3>
<p>Now that we have our basic <code class="highlighter-rouge">RedisModel</code> class we can create new models by just exporting an instance with our schema. For example we could have a <code class="highlighter-rouge">models/log.js</code> file that looks like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre><td class="code"><pre>// models/log.js
import RedisModel from '../lib/redis';

const logSchema = {
  namespace: 'logs',
  indexes: [
    {
      getName: () =&gt; 'createdAt',
      shouldIndex: () =&gt; true,
      addNonTenantIndex: () =&gt; true,
      getValue: data =&gt; new Date(data.createdAt).getTime(),
    },
  ],
  attributes: {
    source: { kind: 'string' },
    user: { kind: 'object' },
    body: { kind: 'object' },
    createdAt: { kind: 'time' },
  },
};

export default new RedisModel(schema);
</pre></table>
</div>
</div>
<p>Then in other parts of our program we can do things like this:
<div class="highlighter-rouge"><div class="highlight"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre><td class="code"><pre>import Log from '../models/log';

// Get a list of logs
const logList = Log.fromIndex('createdAt');

// Find a specific log
Log.findOne('123456');

// Create a new log
Log.create({
  source: 'Web',
  body: 'An error happened',
  user: { email: 'joe@cool.com',  },
  createdAt: new Date(),
});
</pre></table>
</div>
</div>
<p>And based on how we built it, we think about our individual objects in terms of <code class="highlighter-rouge">ids</code> and not keys.
<h3 id="conclusion">Conclusion</h3>
<p>You can see a <a href="https://gist.github.com/nmajor/e772d0dd166c8c3bbffb2bee00faa8a2" title="https://gist.github.com/nmajor/e772d0dd166c8c3bbffb2bee00faa8a2">gist with the full RedisModel class here</a>. Keep in mind this is mostly just to give a possible starting point. Its possible there are some bugs in here since I had to water down my implementation a bit to keep this post concise.
<p>As always, please let me know if you see any issues with the code, or possible problems with my implementation or design choices. I’m always learning.
<p>Thanks for reading!
</article>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'nmajor';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
           <footer>
    <span>A blog filled with adventures in tech</span>
    <span>written by Nicholas Major</span>
</footer>
       </div>
<script type="text/javascript" src="/assets/js/theme.js"></script>
<script type="text/javascript" src="/assets/js/barefoot.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-48130330-1', 'auto');
      ga('send', 'pageview');
    </script>
    
